<!DOCTYPE html>
<html lang="en">
<head>
    <title>zarr-layer wherobots pyramids example</title>
    <meta property="og:description" content="Basic no-build zarr-layer example"/>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css"/>
    <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        html, body, #map {
            height: 100%;
        }
    </style>
</head>
<body>
<div id="map"></div>
<script type="importmap">
{
  "imports": {
    "zarrita": "https://esm.sh/zarrita@0.5.4",
    "proj4": "https://esm.sh/proj4@2.12.1"
  }
}
</script>
<script type="module">
    import {ZarrLayer} from "http://localhost:3001/index.mjs";

    const map = new maplibregl.Map({
        container: "map",
        style: "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json",
        center: [-82.76, 40.13], // Cleveland/Ohio area
        zoom: 6,
        renderWorldCopies: false,
    });

    const layer = new ZarrLayer({
        id: "my-layer",
        source: "https://james-zarr-testing.s3.us-east-2.amazonaws.com/wherobots_mosaic_multi_level3.zarr",
        variable: "variables",
        colormap: [[200, 10, 50], [30, 40, 30], [50, 10, 200]],
        clim: [20, 300],
        opacity: 0.8,
        selector: {
            band: { selected: 0, type: 'index' },
            time: { selected: 0, type: 'index' },
        },
        bounds: [-85.78, 37.72, -79.45, 42.29],
        renderingMode: "2d",
    });

    // Function to convert tile coordinates to lat/lng bounds
    function tileToBounds(x, y, z) {
        const n = Math.PI - (2 * Math.PI * y) / Math.pow(2, z);
        const north = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
        const south = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n - 2 * Math.PI / Math.pow(2, z)) - Math.exp(-(n - 2 * Math.PI / Math.pow(2, z)))));
        const west = (x / Math.pow(2, z)) * 360 - 180;
        const east = ((x + 1) / Math.pow(2, z)) * 360 - 180;
        return { north, south, east, west };
    }

    // Function to generate tile grid GeoJSON for current view
    function generateTileGrid(map) {
        const bounds = map.getBounds();
        const zoom = Math.floor(map.getZoom());
        const features = [];

        // Convert lat/lng to tile coordinates
        function lngLatToTile(lng, lat, z) {
            const x = Math.floor(((lng + 180) / 360) * Math.pow(2, z));
            const latRad = lat * Math.PI / 180;
            const y = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * Math.pow(2, z));
            return { x, y };
        }

        const minTile = lngLatToTile(bounds.getWest(), bounds.getNorth(), zoom);
        const maxTile = lngLatToTile(bounds.getEast(), bounds.getSouth(), zoom);

        for (let x = minTile.x; x <= maxTile.x; x++) {
            for (let y = minTile.y; y <= maxTile.y; y++) {
                const tileBounds = tileToBounds(x, y, zoom);
                features.push({
                    type: 'Feature',
                    properties: { x, y, z: zoom, label: `${zoom}/${x}/${y}` },
                    geometry: {
                        type: 'Polygon',
                        coordinates: [[
                            [tileBounds.west, tileBounds.south],
                            [tileBounds.east, tileBounds.south],
                            [tileBounds.east, tileBounds.north],
                            [tileBounds.west, tileBounds.north],
                            [tileBounds.west, tileBounds.south]
                        ]]
                    }
                });
            }
        }

        return { type: 'FeatureCollection', features };
    }

    map.on("load", () => {
        map.addLayer(layer);

        // Add bounding box to show data extent
        const bounds = [-85.86, 37.81, -79.66, 42.46]; // [west, south, east, north]
        map.addSource('bbox', {
            type: 'geojson',
            data: {
                type: 'Feature',
                geometry: {
                    type: 'Polygon',
                    coordinates: [[
                        [bounds[0], bounds[1]], // SW
                        [bounds[2], bounds[1]], // SE
                        [bounds[2], bounds[3]], // NE
                        [bounds[0], bounds[3]], // NW
                        [bounds[0], bounds[1]]  // close polygon
                    ]]
                }
            }
        });
        map.addLayer({
            id: 'bbox-outline',
            type: 'line',
            source: 'bbox',
            paint: {
                'line-color': '#ff0000',
                'line-width': 3,
                'line-dasharray': [2, 2]
            }
        });

        // Add tile grid source and layers
        map.addSource('tile-grid', {
            type: 'geojson',
            data: generateTileGrid(map)
        });

        map.addLayer({
            id: 'tile-grid-outline',
            type: 'line',
            source: 'tile-grid',
            paint: {
                'line-color': '#0066ff',
                'line-width': 1,
                'line-opacity': 0.6
            }
        });

        map.addLayer({
            id: 'tile-grid-labels',
            type: 'symbol',
            source: 'tile-grid',
            layout: {
                'text-field': ['get', 'label'],
                'text-size': 12,
                'text-anchor': 'center'
            },
            paint: {
                'text-color': '#0066ff',
                'text-halo-color': '#ffffff',
                'text-halo-width': 2
            }
        });

        // Update tile grid on map move
        map.on('moveend', () => {
            map.getSource('tile-grid').setData(generateTileGrid(map));
        });
    });
</script>
</body>
</html>